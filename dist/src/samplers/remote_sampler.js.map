{"version":3,"sources":["../../../src/samplers/remote_sampler.js"],"names":["DEFAULT_INITIAL_SAMPLING_RATE","DEFAULT_REFRESH_INTERVAL","DEFAULT_MAX_OPERATIONS","DEFAULT_SAMPLING_HOST","DEFAULT_SAMPLING_PORT","PROBABILISTIC_STRATEGY_TYPE","RATELIMITING_STRATEGY_TYPE","RemoteControlledSampler","serviceName","options","_serviceName","_sampler","sampler","_logger","logger","_metrics","_refreshInterval","refreshInterval","_host","host","_port","port","_maxOperations","maxOperations","_onSamplerUpdate","onSamplerUpdate","error","randomDelay","Math","random","_initialDelayTimeoutHandle","setTimeout","_afterInitialDelay","bind","name","_refreshIntervalHandle","setInterval","_refreshSamplingStrategy","encodeURIComponent","get","res","setEncoding","body","on","chunk","_parseSamplingServerResponse","err","samplerQueryFailure","increment","samplerRetrieved","strategy","JSON","parse","samplerParsingFailure","toString","_updateSampler","samplerUpdated","response","operationSampling","update","newSampler","strategyType","probabilisticSampling","samplingRate","rateLimitingSampling","maxTracesPerSecond","stringify","equal","operation","tags","isSampled","callback","clearTimeout","clearInterval"],"mappings":"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","file":"remote_sampler.js","sourcesContent":["// @flow\n// Copyright (c) 2016 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nimport http from 'http';\nimport ProbabilisticSampler from './probabilistic_sampler.js';\nimport RateLimitingSampler from './ratelimiting_sampler.js';\nimport PerOperationSampler from './per_operation_sampler.js';\nimport Metrics from '../metrics/metrics.js';\nimport NullLogger from '../logger.js';\nimport NoopMetricFactory from '../metrics/noop/metric_factory';\n\nconst DEFAULT_INITIAL_SAMPLING_RATE = 0.001;\nconst DEFAULT_REFRESH_INTERVAL = 60000;\nconst DEFAULT_MAX_OPERATIONS = 2000;\nconst DEFAULT_SAMPLING_HOST = '0.0.0.0';\nconst DEFAULT_SAMPLING_PORT = 5778;\nconst PROBABILISTIC_STRATEGY_TYPE = 0;\nconst RATELIMITING_STRATEGY_TYPE = 1;\n\nexport default class RemoteControlledSampler {\n\n    _serviceName: string;\n    _sampler: Sampler;\n    _logger: Logger;\n    _metrics: Metrics;\n\n    _refreshInterval: number;\n    _host: string;\n    _port: number;\n    _maxOperations: number;\n\n    _onSamplerUpdate: ?Function;\n\n    _initialDelayTimeoutHandle: any;\n    _refreshIntervalHandle: any;\n\n    /**\n     * Creates a sampler remotely controlled by jaeger-agent.\n     *\n     * @param {string} [serviceName] - name of the current service / application, same as given to Tracer\n     * @param {object} [options] - optional settings\n     * @param {object} [options.sampler] - initial sampler to use prior to retrieving strategies from Agent\n     * @param {object} [options.logger] - optional logger, see _flow/logger.js\n     * @param {object} [options.metrics] - instance of Metrics object\n     * @param {number} [options.refreshInterval] - interval in milliseconds before sampling strategy refreshes (0 to not refresh)\n     * @param {string} [options.host] - host for jaeger-agent, defaults to 'localhost'\n     * @param {number} [options.port] - port for jaeger-agent for SamplingManager endpoint\n     * @param {number} [options.maxOperations] - max number of operations to track in PerOperationSampler\n     * @param {function} [options.onSamplerUpdate]\n     */\n    constructor(serviceName: string, options: any = {}) {\n        this._serviceName = serviceName;\n        this._sampler = options.sampler || new ProbabilisticSampler(DEFAULT_INITIAL_SAMPLING_RATE);\n        this._logger = options.logger || new NullLogger();\n        this._metrics = new Metrics(new NoopMetricFactory());\n        this._refreshInterval = options.refreshInterval || DEFAULT_REFRESH_INTERVAL;\n        this._host = options.host || DEFAULT_SAMPLING_HOST;\n        this._port = options.port || DEFAULT_SAMPLING_PORT;\n        this._maxOperations = options.maxOperations || DEFAULT_MAX_OPERATIONS;\n\n        this._onSamplerUpdate = options.onSamplerUpdate;\n\n        this._logger.error(`JAEGER: Refresh interval is ${options.refreshInterval}`);\n\n        if (options.refreshInterval !== 0) {\n            this._logger.error(`JAEGER: Random delay start`);\n            let randomDelay: number = Math.random() * this._refreshInterval;\n            this._initialDelayTimeoutHandle = setTimeout(this._afterInitialDelay.bind(this), randomDelay);\n        }\n    }\n\n    name(): string {\n        return 'RemoteSampler';\n    }\n\n    toString(): string {\n        return `${this.name()}(serviceName=${this._serviceName})`;\n    }\n\n    _afterInitialDelay(): void {\n        this._refreshIntervalHandle = setInterval(\n            this._refreshSamplingStrategy.bind(this),\n            this._refreshInterval\n        );\n    }\n\n    _refreshSamplingStrategy() {\n        this._logger.error(`JAEGER: refreshSamplingStrategy`);\n        let serviceName: string = encodeURIComponent(this._serviceName);\n        http.get({\n            'host': this._host,\n            'port': this._port,\n            'path': `/sampling?service=${serviceName}`\n        }, (res) => {\n            // explicitly treat incoming data as utf8 (avoids issues with multi-byte chars)\n            res.setEncoding('utf8');\n\n            // incrementally capture the incoming response body\n            let body = '';\n            res.on('data', (chunk) => {\n                body += chunk;\n            });\n\n\n            res.on('end', () => {\n                this._logger.error(`JAEGER: retrieved sampling strategy from agent`, body);\n                this._logger.error(`JAEGER: service is: ${serviceName}`);\n                this._parseSamplingServerResponse(body);\n            });\n        }).on('error', (err) => {\n            this._logger.error(`Error in fetching sampling strategy: ${err}.`);\n            this._metrics.samplerQueryFailure.increment(1);\n        });\n    }\n\n    _parseSamplingServerResponse(body: string) {\n        this._logger.error(`JAEGER: parseSamplingServerResponse`);\n        this._logger.error(`JAEGER: a`);\n        this._metrics.samplerRetrieved.increment(1);\n        this._logger.error(`JAEGER: b`);\n        let strategy;\n        this._logger.error(`JAEGER: parseSamplingServerResponse TRY 1`);\n        try {\n            strategy = JSON.parse(body);\n            if (!strategy) {\n                this._logger.error(`JAEGER: Malformed response!!!!!!!`);\n                throw 'Malformed response: ' + body;\n            }\n        } catch (error) {\n            this._logger.error(`Error in parsing sampling strategy: ${error}.`);\n            this._metrics.samplerParsingFailure.increment(1);\n            return;\n        }\n        this._logger.error(`JAEGER: TRY 1 PASS`);\n        this._logger.error(`JAEGER: TRY 2`);\n        this._logger.error(`JAEGER: PRE sampler: ${this._sampler.toString()}.`);\n        try {\n            if (this._updateSampler(strategy)) {\n                this._metrics.samplerUpdated.increment(1);\n            }\n        } catch (error) {\n            this._logger.error(`Error in updating sampler: ${error}.`);\n            this._metrics.samplerParsingFailure.increment(1);\n            return;\n        }\n        this._logger.error(`JAEGER: TRY 2 PASS`);\n        this._logger.error(`JAEGER: POST sampler: ${this._sampler.toString()}.`);\n        if (this._onSamplerUpdate) {\n            this._onSamplerUpdate(this._sampler);\n        }\n    }\n\n    _updateSampler(response: SamplingStrategyResponse): boolean {\n        this._logger.error(`JAEGER: updateSampler.`);\n        if (response.operationSampling) {\n            if (this._sampler instanceof PerOperationSampler) {\n                let sampler: PerOperationSampler = this._sampler;\n                return sampler.update(response.operationSampling);\n            }\n            this._sampler = new PerOperationSampler(response.operationSampling, this._maxOperations);\n            return true;\n        }\n        let newSampler: Sampler;\n        this._logger.error(`JAEGER: updateSampler TRY`);\n        this._logger.error(`JAEGER: updateSampler response: ${response.strategyType}`);\n        if ((response.strategyType === PROBABILISTIC_STRATEGY_TYPE || response.strategyType === 'PROBABILISTIC') && response.probabilisticSampling) {\n            let samplingRate = response.probabilisticSampling.samplingRate;\n            this._logger.error(`JAEGER: probabilisticSampler: ${samplingRate.toString()}.`);\n            newSampler = new ProbabilisticSampler(samplingRate);\n        } else if (response.strategyType === RATELIMITING_STRATEGY_TYPE && response.rateLimitingSampling) {\n            let maxTracesPerSecond = response.rateLimitingSampling.maxTracesPerSecond;\n            this._logger.error(`JAEGER: rateLimitingSampler ${maxTracesPerSecond.toString()}.`);\n            newSampler = new RateLimitingSampler(maxTracesPerSecond);\n        } else {\n            this._logger.error(`JAEGER: updateSampler Malformed response`);\n            throw 'Malformed response: ' + JSON.stringify(response);\n        }\n        this._logger.error(`JAEGER: updateSampler End`);\n        this._logger.error(`JAEGER: new Sampler: ${newSampler.toString()}.`);\n\n        if (this._sampler.equal(newSampler)) {\n            this._logger.error(`JAEGER: Not updating sampler`);\n            return false;\n        }\n        this._logger.error(`JAEGER: Updating sampler`);\n        this._sampler = newSampler;\n        return true;\n    }\n\n\n    isSampled(operation: string, tags: any): boolean {\n        return this._sampler.isSampled(operation, tags);\n    }\n\n    close(callback: ?Function): void {\n        clearTimeout(this._initialDelayTimeoutHandle);\n        clearInterval(this._refreshIntervalHandle);\n\n        if (callback) {\n            callback();\n        }\n    }\n}\n"]}