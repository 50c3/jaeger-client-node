{"version":3,"sources":["../../../src/reporters/udp_sender.js"],"names":["HOST","PORT","UDP_PACKET_MAX_LENGTH","UDPSender","options","_host","host","_port","port","_maxPacketSize","maxPacketSize","_logger","logger","_client","createSocket","on","error","err","_agentThrift","entryPoint","join","__dirname","allowOptionalArguments","allowFilesystemAccess","_jaegerThrift","source","readFileSync","_totalSpanBytes","batch","Agent","emitBatch","argumentsMessageRW","byteLength","_convertBatchToThriftMessage","_batch","length","span","Span","rw","process","_process","tagMessages","j","tags","tag","push","Tag","_thriftProcessMessage","Process","serviceName","_emitSpanBatchOverhead","_calcBatchSize","_maxSpanBytes","lengthResult","_calcSpanSize","numSpans","spanSize","spans","flush","flushResponse","bufferLen","thriftBuffer","Buffer","writeResult","writeInto","console","log","_reset","send","sent","offset","spanMessages","i","ArgumentsMessage","version","id","body","Batch","close"],"mappings":"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","file":"udp_sender.js","sourcesContent":["// @flow\n// Copyright (c) 2016 Uber Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n// in compliance with the License. You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software distributed under the License\n// is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n// or implied. See the License for the specific language governing permissions and limitations under\n// the License.\n\nimport dgram from 'dgram';\nimport fs from 'fs';\nimport path from 'path';\nimport {Thrift} from 'thriftrw';\nimport NullLogger from '../logger.js';\n\nconst HOST = 'localhost';\nconst PORT =  6832;\nconst UDP_PACKET_MAX_LENGTH = 65000;\n\nexport default class UDPSender {\n    _host: string;\n    _port: number;\n    _maxPacketSize: number;\n    _process: Process;\n    _emitSpanBatchOverhead: number;\n    _logger: Logger;\n    _client: dgram$Socket;\n    _agentThrift: Thrift;\n    _jaegerThrift: Thrift;\n    _batch: Batch;\n    _thriftProcessMessage: any;\n    _maxSpanBytes: number;   // maxPacketSize - (batch + tags overhead)\n    _totalSpanBytes: number; // size of currently batched spans as Thrift bytes\n\n    constructor(options: any = {}) {\n        this._host = options.host || HOST;\n        this._port = options.port || PORT;\n        this._maxPacketSize = options.maxPacketSize || UDP_PACKET_MAX_LENGTH;\n        this._logger = options.logger || new NullLogger();\n        this._client = dgram.createSocket('udp4');\n        this._client.on('error', err => {\n            this._logger.error(`error sending spans over UDP: ${err}`)\n        });\n        this._agentThrift = new Thrift({\n            entryPoint: path.join(__dirname, '../thriftrw-idl/agent.thrift'),\n            allowOptionalArguments: true,\n            allowFilesystemAccess: true\n        });\n        this._jaegerThrift = new Thrift({\n            source: fs.readFileSync(path.join(__dirname, '../jaeger-idl/thrift/jaeger.thrift'), 'ascii'),\n            allowOptionalArguments: true\n        });\n        this._totalSpanBytes = 0;\n    }\n\n    _calcBatchSize(batch: Batch) {\n        return this._agentThrift.Agent.emitBatch.argumentsMessageRW.byteLength(\n            this._convertBatchToThriftMessage(this._batch)\n        ).length;\n    }\n\n    _calcSpanSize(span: any): LengthResult {\n        return this._jaegerThrift.Span.rw.byteLength(new this._jaegerThrift.Span(span));\n    }\n\n    setProcess(process: Process): void {\n        // This function is only called once during reporter construction, and thus will\n        // give us the length of the batch before any spans have been added to the span\n        // list in batch.\n        this._process = process;\n        this._batch = {\n            'process': this._process,\n            'spans': []\n        };\n\n        let tagMessages = [];\n        for (let j = 0; j < this._batch.process.tags.length; j++) {\n            let tag = this._batch.process.tags[j];\n            tagMessages.push(new this._jaegerThrift.Tag(tag));\n        }\n\n        this._thriftProcessMessage = new this._jaegerThrift.Process({\n            serviceName: this._batch.process.serviceName,\n            tags: tagMessages\n        });\n        this._emitSpanBatchOverhead = this._calcBatchSize(this._batch);\n        this._maxSpanBytes = this._maxPacketSize - this._emitSpanBatchOverhead;\n    }\n\n    append(span: any): SenderResponse {\n        let lengthResult: LengthResult = this._calcSpanSize(span);\n        if (lengthResult.err) {\n            this._logger.error(`error converting span to Thrift: ${lengthResult.err}`);\n            return { err: true, numSpans: 1 };\n        }\n        let spanSize: number = lengthResult.length;\n        if (spanSize > this._maxSpanBytes) {\n            return { err: true, numSpans: 1 };\n        }\n\n        if (this._totalSpanBytes + spanSize <= this._maxSpanBytes) {\n            this._batch.spans.push(span);\n            this._totalSpanBytes += spanSize;\n            if (this._totalSpanBytes < this._maxSpanBytes) {\n                // still have space in the buffer, don't flush it yet\n                return {err: false, numSpans: 0};\n            }\n            return this.flush();\n        }\n\n        let flushResponse: SenderResponse = this.flush();\n        this._batch.spans.push(span);\n        this._totalSpanBytes = spanSize;\n        return flushResponse;\n    }\n\n    flush(): SenderResponse {\n        let numSpans: number = this._batch.spans.length;\n        if (numSpans == 0) {\n            return {err: false, numSpans: 0}\n        }\n\n        let bufferLen = this._totalSpanBytes + this._emitSpanBatchOverhead;\n        let thriftBuffer = new Buffer(bufferLen);\n        let writeResult;\n\n        try {\n            writeResult = this._agentThrift.Agent.emitBatch.argumentsMessageRW.writeInto(\n                this._convertBatchToThriftMessage(this._batch), thriftBuffer, 0\n            );\n        } catch(err) {\n            this._logger.error(`error writing Thrift object: ${err}, batch: ${this._batch}, length: ${bufferLen}`);\n            console.log(`error writing Thrift object: ${err}, batch: ${this._batch}, length: ${bufferLen}`);\n            this._reset();\n            return {err: true, numSpans: numSpans};\n        }\n\n        if (writeResult.err) {\n            this._logger.error(`error writing Thrift object: ${writeResult.err}`);\n            return {err: true, numSpans: numSpans};\n        }\n\n        // Having the error callback here does not prevent uncaught exception from being thrown,\n        // that's why in the constructor we also add a general on('error') handler.\n        this._client.send(thriftBuffer, 0, thriftBuffer.length, this._port, this._host, (err, sent) => {\n            if (err) {\n                this._logger.error(`error sending spans over UDP: ${err}, packet size: ${writeResult.offset}, bytes sent: ${sent}`);\n            }\n        });\n        this._reset();\n\n        return {err: false, numSpans: numSpans};\n    }\n\n    _convertBatchToThriftMessage() {\n        let spanMessages = [];\n        for (let i = 0; i < this._batch.spans.length; i++) {\n            let span = this._batch.spans[i];\n            spanMessages.push(new this._jaegerThrift.Span(span))\n        }\n\n        return new this._agentThrift.Agent.emitBatch.ArgumentsMessage({\n            version: 1,\n            id: 0,\n            body: {batch: new this._jaegerThrift.Batch({\n                    process: this._thriftProcessMessage,\n                    spans: spanMessages\n            })}\n        });\n    }\n\n    _reset() {\n        this._batch.spans = [];\n        this._totalSpanBytes = 0;\n    }\n\n    close(): void {\n        this._client.close();\n    }\n}\n"]}